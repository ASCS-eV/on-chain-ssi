{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-6d748ba5b73d5485295d0e70f5a8141317d861af",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/DIDMultisigController.sol": "project/contracts/DIDMultisigController.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/DIDMultisigController.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IEthereumDIDRegistry {\n    function changeOwner(address identity, address newOwner) external;\n    function addDelegate(address identity, bytes32 delegateType, address delegate, uint validity) external;\n    function revokeDelegate(address identity, bytes32 delegateType, address delegate) external;\n    function setAttribute(address identity, bytes32 name, bytes calldata value, uint validity) external;\n    function revokeAttribute(address identity, bytes32 name, bytes calldata value) external;\n}\n\ncontract DIDMultisigController {\n    /*//////////////////////////////////////////////////////////////\n                                STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    IEthereumDIDRegistry public immutable registry;\n    address[] public owners;\n    mapping(address => bool) public isOwner;\n\n    uint256 public quorum; // Standard M-of-N for routine tasks\n\n    struct Proposal {\n        bytes data;\n        uint256 approvals;\n        bool executed;\n        bool requiresUnanimity;\n        address ownerToRemove;\n        mapping(address => bool) approvedBy;\n    }\n\n    mapping(bytes32 => Proposal) public proposals;\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event ProposalCreated(bytes32 indexed id, bytes data, bool requiresUnanimity);\n    event Approved(bytes32 indexed id, address indexed owner);\n    event Executed(bytes32 indexed id);\n    event QuorumUpdated(uint256 newQuorum);\n    event OwnerAdded(address indexed newOwner);\n    event OwnerRemoved(address indexed removedOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    modifier onlyOwner() {\n        require(isOwner[msg.sender], \"not_owner\");\n        _;\n    }\n\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"only_self\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        address _registry,\n        address[] memory _owners,\n        uint256 _quorum\n    ) {\n        require(_owners.length > 0, \"no_owners\");\n        require(_quorum > 0 && _quorum <= _owners.length, \"bad_quorum\");\n\n        registry = IEthereumDIDRegistry(_registry);\n        quorum = _quorum;\n\n        for (uint i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n            require(owner != address(0), \"zero_owner\");\n            require(!isOwner[owner], \"duplicate_owner\");\n            isOwner[owner] = true;\n            owners.push(owner);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         1. SINGLE ADMIN ACTIONS\n             (For managing Company DIDs - Speed Layer)\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Allows a single admin to execute calls on external contracts (Companies).\n     * @dev RESTRICTED: Cannot call the Registry to modify THIS contract's identity.\n     */\n    function execCall(address target, bytes calldata data) external onlyOwner {\n        // Security Check: If calling the Registry, ensure we are NOT modifying our own identity.\n        if (target == address(registry)) {\n            // Registry functions usually start with (address identity, ...)\n            // We decode the first 32 bytes of the payload (after the 4-byte selector)\n            // to check the 'identity' argument.\n            require(data.length >= 36, \"invalid_data_length\");\n\n            // Slice out the 4-byte selector to decode the args\n            bytes memory args = data[4:];\n            // Decode strictly as (address) to get the first parameter\n            address identityParam = abi.decode(args, (address));\n\n            require(identityParam != address(this), \"use_proposal_for_self\");\n        }\n\n        (bool success, ) = target.call(data);\n        require(success, \"call_failed\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            2. PROPOSAL LOGIC\n                 (For Consensus Actions - Security Layer)\n    //////////////////////////////////////////////////////////////*/\n\n    function _propose(bytes memory data, bool requiresUnanimity, address ownerToRemove) internal returns (bytes32 id) {\n        id = keccak256(abi.encode(address(this), data, block.timestamp));\n        Proposal storage p = proposals[id];\n        require(p.data.length == 0, \"already_exists\");\n\n        p.data = data;\n        p.requiresUnanimity = requiresUnanimity;\n        p.ownerToRemove = ownerToRemove;\n\n        emit ProposalCreated(id, data, requiresUnanimity);\n    }\n\n    function approve(bytes32 id) external onlyOwner {\n        Proposal storage p = proposals[id];\n        require(p.data.length != 0, \"no_proposal\");\n        require(!p.executed, \"already_executed\");\n        require(!p.approvedBy[msg.sender], \"already_approved\");\n\n        p.approvedBy[msg.sender] = true;\n        p.approvals++;\n\n        emit Approved(id, msg.sender);\n\n        _tryExecute(id);\n    }\n\n    function _tryExecute(bytes32 id) internal {\n        Proposal storage p = proposals[id];\n        uint256 threshold;\n\n        if (p.requiresUnanimity) {\n            if (p.ownerToRemove != address(0)) {\n                threshold = owners.length - 1;\n            } else {\n                threshold = owners.length;\n            }\n        } else {\n            threshold = quorum;\n        }\n\n        if (p.approvals >= threshold) {\n            p.executed = true;\n            // Calls a function on THIS contract (which then calls Registry)\n            (bool ok,) = address(this).call(p.data);\n            require(ok, \"execution_failed\");\n            emit Executed(id);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     3. CRITICAL ACTIONS (UNANIMOUS)\n    //////////////////////////////////////////////////////////////*/\n\n    function proposeChangeOwner(address identity, address newOwner) external onlyOwner returns (bytes32) {\n        return _propose(\n            abi.encodeWithSelector(this._executeChangeOwner.selector, identity, newOwner),\n            true,\n            address(0)\n        );\n    }\n\n    function _executeChangeOwner(address identity, address newOwner) external onlySelf {\n        registry.changeOwner(identity, newOwner);\n    }\n\n    function proposeAddOwner(address newOwner) external onlyOwner returns (bytes32) {\n        require(!isOwner[newOwner], \"already_owner\");\n        return _propose(\n            abi.encodeWithSelector(this._addOwner.selector, newOwner),\n            true,\n            address(0)\n        );\n    }\n\n    function _addOwner(address newOwner) external onlySelf {\n        isOwner[newOwner] = true;\n        owners.push(newOwner);\n        emit OwnerAdded(newOwner);\n    }\n\n    function proposeRemoveOwner(address owner) external onlyOwner returns (bytes32) {\n        require(isOwner[owner], \"not_owner\");\n        return _propose(\n            abi.encodeWithSelector(this._removeOwner.selector, owner),\n            true,\n            owner\n        );\n    }\n\n    function _removeOwner(address owner) external onlySelf {\n        require(owners.length - 1 >= quorum, \"quorum_violation\");\n\n        isOwner[owner] = false;\n        for (uint i = 0; i < owners.length; i++) {\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                owners.pop();\n                break;\n            }\n        }\n        emit OwnerRemoved(owner);\n    }\n\n    function proposeQuorumUpdate(uint256 newQuorum) external onlyOwner returns (bytes32) {\n        return _propose(\n            abi.encodeWithSelector(this._setQuorum.selector, newQuorum),\n            true,\n            address(0)\n        );\n    }\n\n    function _setQuorum(uint256 newQuorum) external onlySelf {\n        require(newQuorum > 0 && newQuorum <= owners.length, \"bad_quorum\");\n        quorum = newQuorum;\n        emit QuorumUpdated(newQuorum);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     4. ROUTINE ACTIONS (QUORUM)\n               (For managing THIS contract's identity)\n    //////////////////////////////////////////////////////////////*/\n\n    // WRAPPER 1: Set Attribute\n    function proposeSetAttribute(bytes32 name, bytes calldata value, uint validity) external onlyOwner returns (bytes32) {\n        // Target THIS contract's wrapper function\n        return _propose(\n            abi.encodeWithSelector(this._setAttribute.selector, name, value, validity),\n            false, // Quorum\n            address(0)\n        );\n    }\n\n    function _setAttribute(bytes32 name, bytes calldata value, uint validity) external onlySelf {\n        // Multisig calls registry for ITSELF\n        registry.setAttribute(address(this), name, value, validity);\n    }\n\n    // WRAPPER 2: Add Delegate\n    function proposeAddDelegate(bytes32 delegateType, address delegate, uint validity) external onlyOwner returns (bytes32) {\n        return _propose(\n            abi.encodeWithSelector(this._addDelegate.selector, delegateType, delegate, validity),\n            false, // Quorum\n            address(0)\n        );\n    }\n\n    function _addDelegate(bytes32 delegateType, address delegate, uint validity) external onlySelf {\n        registry.addDelegate(address(this), delegateType, delegate, validity);\n    }\n}"
      }
    }
  }
}